<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../app-scroll-behaviors/app-document-scroll-behavior.html">

<!--
app-header-layout lays out an app-header and a content. This element uses the document scroll
by default, but it can also define its own scrolling region.

Using the document scroll:

```html
<app-header-layout>
  <app-header fixed condenses effects="waterfall">
    <app-toolbar>
      <div title>App name</div>
    </app-toolbar>
  </app-header>
  <div>
    <!\-\- content goes here \-\->
  </div>
</app-header-layout>
```

Using an own scrolling region:

```html
<app-header-layout has-scrolling-region style="width: 300px; height: 400px;">
  <app-header fixed condenses effects="waterfall">
    <app-toolbar>
      <div title>App name</div>
    </app-toolbar>
  </app-header>
  <div>
    <!\-\- content goes here \-\->
  </div>
</app-header-layout>
```

@demo app-header-layout/demo1.html
@demo app-header-layout/demo2.html
-->

<dom-module id="app-header-layout">

  <style>

    :host {
      display: block;
    }

    :host([has-scrolling-region]) {
      position: relative;
      height: 100%;
    }

    :host > ::content > app-header,
    :host > ::content > [underlay-content] {
      position: fixed;
      top: 0;
      right: 0;
      left: 0;
    }

    :host([has-scrolling-region]) > ::content > app-header,
    :host([has-scrolling-region]) > ::content > [underlay-content] {
      position: absolute;
    }

    :host([has-scrolling-region]) > #contentContainer {
      @apply(--layout-fit);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    #contentContainer {
      position: relative;
      overflow-y: hidden;
    }

  </style>

  <template>

    <content id="underlayContent" select="[underlay-content]"></content>

    <div id="contentContainer">
      <content select=":not(app-header):not([app-header-overlay])"></content>
    </div>

    <content id="header" select="app-header"></content>

    <content select="[app-header-overlay]"></content>

  </template>

  <script>

    Polymer({

      is: 'app-header-layout',

      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.AppDocumentScrollBehavior
      ],

      properties: {

        /**
         * If true, the current element will have its own scrolling region.
         * Otherwise, it will use the document scroll to control the header.
         */
        hasScrollingRegion: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: '_hasScrollingRegionChanged'
        },

        disabled: {
          type: Boolean,
          value: false
        }

      },

      listeners: {
        'iron-resize': '_resizeHandler',
        'app-header-reset-layout': 'resetLayout'
      },

      observers: [
        'resetLayout(isAttached, hasScrollingRegion)',
        '_disabledChanged(disabled)'
      ],

      _savedPageYOffset: 0,

      get header() {
        return Polymer.dom(this.$.header).getDistributedNodes()[0];
      },

      /**
       * Resets the layout. This method is automatically called when the element is attached to the DOM.
       *
       * @method resetLayout
       */
      resetLayout: function() {
        this.debounce('_resetLayout', function() {
          this._updateContentPosition();
          this._updateScroller();
        }, 3);
      },

      // When app-header-layout is disabled, we disable scrolling on the main content. On non-iOS
      // devices, we do this by setting <body>.style.overflow = 'hidden'; this is done in
      // <app-drawer> so that the functionality is provided when not using <app-header-layout>.
      // This does not work on iOS devices which does scrolling on a separate layer; to overcome
      // this, we use hacks that require a certain DOM structure, so this functionality is only
      // available with <app-header-layout>.
      _disabledChanged: function(disabled) {
        var header = this.header;
        if (!header) {
          return;
        }

        if (disabled) {
          if (this.hasScrollingRegion) {
            // If scrolling is done inside an element with webkitOverflowScrolling = 'touch' (i.e.
            // not document scrolling), then we can just set webkitOverflowScrolling = 'auto' to
            // disable scrolling.
            this.$.contentContainer.style.webkitOverflowScrolling = 'auto';
          } else {
            // If we are using document scrolling, we disable the header to stop any scrolling
            // effects, resize the height <app-header-layout> to the viewport height, and
            // vertically translate the contents to simulate disabled scrolling. We also save the
            // last scroll position so we can restore it later.
            header.disabled = true;
            this._savedPageYOffset = window.pageYOffset;
            this.style.height  = window.innerHeight + 'px';
            this.style.overflow = 'hidden';
            this.transform('translateY(-' + this._savedPageYOffset + 'px)', this.$.contentContainer);
          }
        } else {
          if (this.hasScrollingRegion) {
            this.$.contentContainer.style.webkitOverflowScrolling = '';
          } else {
            this.style.height = '';
            this.style.overflow = '';
            this.transform('', this.$.contentContainer);
            window.scrollTo(window.pageXOffset, this._savedPageYOffset);
            header.disabled = false;
          }
        }
      },

      _getFixedNodes: function() {
        return Polymer.dom(this.$.header).getDistributedNodes().
            concat(Polymer.dom(this.$.underlayContent).getDistributedNodes());
      },

      _updateContentPosition: function() {
        var header = this.header;
        var containerStyle = this.$.contentContainer.style;
        if (!this.isAttached || !header) {
          return;
        }
        this._headerHeight = header.offsetHeight;
        if (header.fixed && !header.willCondense() && this.hasScrollingRegion) {
          containerStyle.marginTop = this._headerHeight + 'px';
          containerStyle.paddingTop = '';
        } else {
          containerStyle.paddingTop = this._headerHeight + 'px';
          containerStyle.marginTop = '';
        }
      },

      _updateFixedNodesPosition: function() {
        var rect = this.getBoundingClientRect();
        this._getFixedNodes().forEach(function(node) {
          // if it's a header, check if the scroller is the document
          if (node && (!node.scroller || node.scroller === window)) {
            node.style.left = this.hasScrollingRegion ? '' : rect.left + 'px';
            node.style.width = this.hasScrollingRegion ? '' : rect.width + 'px';
          }
        }.bind(this));
      },

      _hasScrollingRegionChanged: function(hasScrollingRegion) {
        // the user should be able to scroll
        this.shouldEnableScroll(hasScrollingRegion, this.$.contentContainer);
        this._updateScroller();
      },

      _updateScroller: function() {
        if (!this.isAttached) {
          return;
        }
        var header = this.header;
        if (header) {
          header.scroller = this.hasScrollingRegion ? this.$.contentContainer : window;
          this._updateFixedNodesPosition();
        }
      },

      _resizeHandler: function() {
        this.resetLayout();
      }

    });

  </script>

</dom-module>
